<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>graph ui</title>
    <style>
      :root {
        --sans-font: -apple-system, BlinkMacSystemFont, "Avenir Next", Avenir,
          "Nimbus Sans L", Roboto, "Noto Sans", "Segoe UI", Arial, Helvetica,
          "Helvetica Neue", sans-serif;
        --bg: #f5f7ff;
        --text: #212121;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          color-scheme: dark;
          --bg: #212121;
          --text: #dcdcdc;
        }
      }

      *, *::before, *::after {
        box-sizing: border-box;
      }

      html {
        font-family: var(--sans-font);
        scroll-behavior: smooth;
      }

      body {
        color: var(--text);
        background-color: var(--bg);
        font-size: 1.15rem;
        line-height: 1.5;
        display: grid;
        grid-template-columns: 1fr min(45rem, 90%) 1fr;
        margin: 0;
      }

      body > * {
        grid-column: 2;
      }

      board-element {
        display: block;
        border: 2px solid gray;
        min-height: 40vh;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Graph UI</h1>
      <board-element></board-element>
      <p>
        This example is based on this <a href="https://zenn.dev/aishift/articles/4649f6af5d175b">article</a>.
      </p>
      <a href="/" >back to home</a>
    </main>
    <script type="module">
      import {
        LitElement,
        css,
        html,
        nothing,
        styleMap
      } from 'https://cdn.jsdelivr.net/gh/lit/dist@3/all/lit-all.min.js';

      // HACK globalThis has some additional properties
      // ___boardRect DOMRect of BoardElement

      class NodeElement extends LitElement {
        static styles = css`
          .node {
            /* for node outline */
            border: solid 1px;
            width: 120px;
            height: 40px;
            border-radius: 6px;
            padding: 8px 16px;

            /* for node content layout */
            display: flex;
            justify-content: center;
            align-items: center;

            cursor: pointer;
          }

          .node-outside {
            display: flex;
            flex-direction: column;
            align-items: center;
          }

          .connector {
            width: 10px;
            height: 10px;
            border: solid 1px;
            border-radius: 50%;
            cursor: pointer;
          }

          .node-wrapper {
            position: absolute;
          }
        `

        static properties = {
          id: { type: String, reflect: true },
          position: { type: Object, reflect: true },
        }

        render() {
          const transform = {
            transform: `translate(${this.position.x}px, ${this.position.y}px)`
          }
          return html`
            <div
              class="node-wrapper"
              style=${styleMap(transform)}
            >
              <div class="node-outside">
                <div
                  class="connector"
                  data-placement="Top"
                  @mousedown=${this._handleConnect}
                ></div>
                <div
                  class="node"
                  @mousedown=${this._handleMouseDown}
                >
                  x: ${this.position.x}, y: ${this.position.y}
                </div>
                <div
                  class="connector"
                  data-placement="Bottom"
                  @mousedown=${this._handleConnect}
                /></div>
              </div>
            </div>
          `
        }

        constructor() {
          super()
          this.position = { x: 0, y: 0 }
        }

        _handleMouseDown(e) {
          e.cancelBubble = true
          const detail = { selectedNodeId: this.id }
          // console.log('from node: ', detail)
          const event = new CustomEvent('nodeselect', {
            detail,
            bubbles: true,
            composed: true,
            cancelable: true,
          })
          this.dispatchEvent(event)
          if (event.defaultPrevented) {
            e.preventDefault()
          }
        }

        _handleConnect(e) {
          e.stopPropagation()
          // Connector's DOMRect
          const connectorRect = e.currentTarget.getBoundingClientRect()
          // HACK BoardElement boarder size
          const boarderPX = 2
          const placement = e.currentTarget.dataset.placement
          // Change position by connection placement
          const placementFix =
            placement === "Top"
              ? 0
              : connectorRect.height
          const position = {
            x: connectorRect.x - globalThis.___boardRect.x
              + (connectorRect.width / 2)
              - boarderPX,
            y: connectorRect.y - globalThis.___boardRect.y
                + (placementFix)
                - boarderPX
          }
          const detail = {
            id: this.id,
            from: position,
            to: position,
          }
          const event = new CustomEvent('connectstart', {
            detail,
            bubbles: true,
            composed: true,
            cancelable: true,
          })
          this.dispatchEvent(event)
        }
      }

      customElements.define("node-element", NodeElement)

      class EdgeElement extends LitElement {
        static properties = {
          from: { type: Object },
          to: { type: Object }
        };
        // Define scoped styles right with your component, in plain CSS
        static styles = css`
          .edge-wrapper {
            position: absolute;
            pointer-events: none;
          }

          .svg {
            width: 100vw;
            height: 100vh;
          }
        `;

        constructor() {
          super()
          // Declare reactive properties
          this.from = { x: 0, y: 0 }
          this.to = { x: 100, y: 100 }
        }

        // Render the UI as a function of component state
        render() {
          return html`
            <div class="edge-wrapper">
              <svg class="svg">
                <path
                  stroke="#dcdcdc"
                  strokeWidth="2"
                  fill="none"
                  d="M ${this.from.x}, ${this.from.y} L ${this.to.x}, ${this.to.y}"
                />
              </svg>
            </div>
          `;
        }
      }
      customElements.define('edge-element', EdgeElement)

      // Singleton class
      class BoardElement extends LitElement {
        static styles = css`
          .board {
            position: relative;
            width: 100%;
            height: 100%;
          }
        `

        static properties = {
          nodes : { type: Array, reflect: true },
          _selectedNodeId: { state: true },
          _newEdge: { state: true }
        }

        constructor() {
          super();
          this.nodes = [
            {
              id: "node1",
              position: { x: 0, y: 0 },
            },
            {
              id: "node2",
              position: { x: 400, y: 100 },
            },
          ]
          this._selectedNodeId = null
          this._newEdge = null
          globalThis.___boardRect = this.getBoundingClientRect()
        }

        _onConnectStart(e) {
          this._newEdge = {
            from: e.detail.from,
            to: e.detail.to,
          }
        }

        _onNodeSelect(e) {
          const id = e.detail.selectedNodeId
          if (typeof id === 'string') {
            this._selectedNodeId = id
            // reset newEdge
            this._newEdge = null
          }
        }

        _handleMouseDownBoard(event) {
          this._newEdge = null
        }

        _handleMouseUpBoard() {
          this._selectedNodeId = null
        }

        _handleMouseMoveBoard(event) {
          if (this._selectedNodeId) {
            const selectedNode = this.nodes.find((node) => node.id === this._selectedNodeId)
            if (!selectedNode) return
            this.nodes = this.nodes.map((node) => {
              return selectedNode.id === node.id ? {
                ...node,
                position: {
                  x: node.position.x + event.movementX,
                  y: node.position.y + event.movementY,
                }
              } : node
            })
          }

          if (this._newEdge) {
            this._newEdge = {
              ...this._newEdge,
              to: {
                x: event.clientX - globalThis.___boardRect.x,
                y: event.clientY - globalThis.___boardRect.y,
              }
            }
          }
        }

        render() {
          return html`
            <div
              class="board"
              @mousedown=${this._handleMouseDownBoard}
              @mousemove=${this._handleMouseMoveBoard}
              @mouseup=${this._handleMouseUpBoard}
              @mouseleave=${this._handleMouseUpBoard}
            >
              ${this._newEdge
                ? html`
                  <edge-element
                    from="${JSON.stringify(this._newEdge.from)}"
                    to="${JSON.stringify(this._newEdge.to)}"
                  ></edge-element>`
                : nothing
              }
              ${this.nodes.map((node) => (
                html`
                  <node-element
                    key="${node.id}""
                    id="${node.id}""
                    position="${JSON.stringify(node.position)}"
                    @nodeselect=${this._onNodeSelect}
                    @connectstart=${this._onConnectStart}
                  />
                `
              ))}
            </div>
          `
        }
      }

      customElements.define("board-element", BoardElement);
    </script>
  </body>
</html>
